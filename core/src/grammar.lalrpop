grammar;

use crate::ast::*;

pub Program: Program = {
    <p:Clause*> => Program(p),
}

pub Query: Query = {
    <p:Comma<Predicate>> "." => Query(p),
}

pub Clause: Clause = {
    <h:Predicate> "." => Clause(h, vec![]),
    <h:Predicate> ":-" <b:Comma<Predicate>> "." => Clause(h, b),
}

pub Predicate: Predicate = {
    <a:Atom> => Predicate::Atom(a),
    <f:AtomStr> "(" <a:Comma<Term>> ")" => Predicate::Compound(f, a),
}

pub Term: Term = {
    <a:Atom> => Term::Atom(a),
    <v:VarStr> => Term::Variable(v),
    <f:AtomStr> "(" <a:Comma<Term>> ")" => Term::Compound(f, a),
}

pub Atom: Atom = {
    <s:AtomStr> => Atom::String(s),
    <i:Integer> => Atom::Integer(i),
    <f:Float>   => Atom::Float(f),
}

pub AtomStr: String = r"([a-z][a-zA-Z0-9_]*)|=|>|<|>=|<=|=\\=|=:=|\+|-|\/|\*" => <>.to_string(); // TODO: add operators
pub VarStr: String = r"[A-Z][a-zA-Z0-9_]*" => <>.to_string();
pub Integer: i64 = r"-?[0-9]+" => <>.parse().unwrap();
pub Float: f64 = r"-?[0-9]+\.[0-9]+" => <>.parse().unwrap();

Comma<T>: Vec<T> = {
    <t:T> => vec![t],
    <mut ts:Comma<T>> "," <t:T> => {
        ts.push(t);
        ts
    },
}