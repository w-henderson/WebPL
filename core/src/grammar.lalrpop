grammar;

use crate::ast::*;

pub Program: Program = {
    <p:Clause*> => Program(p),
}

pub Query: Query = {
    () => Query(vec![]),
    <p:Comma<Term>> "." => Query(p),
}

Clause: Clause = {
    <h:Term> "." => Clause(h, vec![]),
    <h:Term> ":-" <b:Comma<Term>> "." => Clause(h, b),
}

Term: Term = {
    #[precedence(level="0")]
    <a:Atom> => Term::Atom(a),
    <v:VarStr> => Term::Variable(v),
    <f:AtomStr> "(" <a:Comma<Term>> ")" => Term::Compound(f, a),
    "(" <t:BracketedTerm> ")" => t,

    "[" <a:Comma<Term>> "|" <t:Term> "]" => Term::list(a, Some(t)),
    "[" <a:Comma<Term>> "]" => Term::list(a, None),
    "[]" => Term::list(vec![], None),

    <t:LambdaTerm> => t,

    "!" => Term::Cut,

    #[precedence(level="1")] #[assoc(side="left")]
    <t1:Term> <o:Op1> <t2:Term> => Term::Compound(o, vec![t1, t2]),

    #[precedence(level="2")] #[assoc(side="left")]
    <t1:Term> <o:Op2> <t2:Term> => Term::Compound(o, vec![t1, t2]),

    #[precedence(level="3")] #[assoc(side="left")]
    <t1:Term> <o:Op3> <t2:Term> => Term::Compound(o, vec![t1, t2]),
}

LambdaTerm: Term = {
    <js:r"<\{.*\}>"> =>? Term::parse_lambda(js)
        .map_err(|error| lalrpop_util::ParseError::User { error }),
}

// https://github.com/lalrpop/lalrpop/issues/596
BracketedTerm: Term = <Term>;

Atom: Atom = {
    <s:AtomStr> => Atom::String(s),
    <i:Integer> => Atom::Integer(i),
    <f:Float>   => Atom::Float(f),
}

Op1: String = r"\*|\/|\/\/| mod " => <>.trim().to_string();
Op2: String = r"\+|-" => <>.trim().to_string();
Op3: String = r"=|>|<|>=|=<|=\\=|=:=| is " => <>.trim().to_string();

AtomStr: String = r"[a-z][a-zA-Z0-9_]*" => <>.to_string();
VarStr: String = r"[A-Z_][a-zA-Z0-9_]*" => <>.to_string();
Integer: i64 = r"-?[0-9]+" => <>.parse().unwrap();
Float: f64 = r"-?[0-9]+\.[0-9]+" => <>.parse().unwrap();

Comma<T>: Vec<T> = {
    <t:T> => vec![t],
    <mut ts:Comma<T>> "," <t:T> => {
        ts.push(t);
        ts
    },
}

match {
    r"\s*" => { },                                   // Skip whitespace
    r"%[^\n\r]*[\n\r]*" => { },                      // Skip `%` comments
    r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" => { },        // Skip `/* */` comments
    _
}