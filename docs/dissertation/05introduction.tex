\chapter{Introduction}

This dissertation explores the use of Prolog in the browser by building a Prolog interpreter, WebPL, with a particular focus on performance and browser integration. This chapter introduces the motivation for the project, briefly discussing the existing landscape of Prolog implementations for the browser, and outlines the aims of the project.

\section{Motivation}

Web pioneer Marc Andreessen claimed in the early days of the Web that ``the browser will be the operating system'': the browser would become the platform on which modern applications are built \cite{kosnerAlwaysEarlyMarc2012}. This vision has largely proved correct, with increasingly sophisticated applications being delivered through the browser. In the last decade, the development of WebAssembly, a low-level binary instruction format for the Web, has further bridged the gap between browser-based and native applications, enabling web applications to run with near-native performance \cite{haasBringingwebspeed2017}.

The Prolog logic programming language is not exempt from this trend. Prolog is used on the Web in a variety of applications, including for browser-based development environments like SWISH \cite{wielemakerSWISHSWIPrologSharing2015}, enforcing dependency constraints in JavaScript packages\footnote{\url{https://v3.yarnpkg.com/features/constraints}}, and as a query language for databases \cite{wielemakerUsingPrologFundament2007}.

There are several Prolog implementations that run in the browser, which fall into two categories: existing general-purpose native implementations that have been ported to WebAssembly, which I will call \emph{web-ported} implementations, and implementations that have been designed from the ground up specifically for the Web, which I will call \emph{web-native} implementations. The former category includes SWI-Prolog \cite{wielemakerSWIProlog2012} and Trealla Prolog \cite{davisonTreallaProlog2020}, while a notable example of the latter is Tau Prolog \cite{riazaTauPrologProlog2024}, written in JavaScript. At the time of writing, there are no web-native implementations that use WebAssembly.

Web-ported implementations enjoy WebAssembly's near-native performance but suffer from poor integration with the browser environment and large binary sizes. The resource requirements of applications in the browser differ greatly from those of native applications, particularly in terms of memory, and web-ported implementations are typically heavyweight and do not take this into account.

Web-native implementations, on the other hand, are more tightly integrated with the browser environment, but currently miss out on the performance benefits of WebAssembly. Furthermore, JavaScript's memory management is entirely independent of the Prolog engine, so information about the state of the Prolog engine cannot be used to optimise allocation and deallocation of memory.

There is a third approach, taken by some browser-based Prolog systems, which is to run the Prolog engine on a server and communicate with it through a client-server model. The browser-based Prolog development environment SWISH is one such system \cite{wielemakerSWISHSWIPrologSharing2015}. SWI-Prolog runs on the server, communicating with the browser using Pengines, a library for exchanging Prolog queries and results over HTTP \cite{lagerPenginesWebLogic2014}. This has similar performance to web-ported implementations, albeit with greater latency, but has the added complexity and failure modes of a client-server architecture.

I hypothesise that \textbf{a web-native Prolog implementation using WebAssembly, with design guided by the constraints of the browser environment, may be able to achieve superior performance compared to existing implementations while preserving tight integration with the browser}.

The project aims to explore this hypothesis by building such a Prolog implementation.

\section{Project Aims}

The aims of the project are as follows:

\begin{itemize}
\item to \textbf{build a web-native Prolog implementation} that uses WebAssembly, with a particular focus on performance and browser integration, including
\begin{itemize}
\item a \textbf{lexer} and \textbf{parser} for \emph{pure Prolog}\footnote{So as not to distract from the focus of performance and browser integration, the project considers a subset of Prolog, roughly equivalent to the content of the Cambridge Computer Science Part IB Prolog course. Appendix \ref{appendix:pure-prolog} comprises a detailed definition of the subset.} programs, and
\item an \textbf{interpreter} for the parsed programs,
\end{itemize}
\item to \textbf{make optimisations} to improve performance, including both traditional Prolog optimisations and those that specifically target the browser environment, and
\item to \textbf{evaluate its performance}, both in terms of execution time and memory usage, against existing web-ported and web-native Prolog implementations, exploring which factors contribute to the performance differences.
\end{itemize}

As extensions, the project has the following additional aims:

\begin{itemize}
\item to \textbf{build a browser-based development environment} for the Prolog implementation, similar to SWISH, which supports \textbf{plugins} for other Prolog implementations to facilitate comparison,
\item to \textbf{implement a garbage collector} to make more efficient use of memory, and
\item to \textbf{develop a foreign function interface}, extending the Prolog syntax to support \textbf{inline JavaScript code}, to integrate with the browser environment.
\end{itemize}