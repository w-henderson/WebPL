@book{ait-kaciWarrensAbstractMachine1991,
  title = {Warren's {{Abstract Machine}}: {{A Tutorial Reconstruction}}},
  shorttitle = {Warren's {{Abstract Machine}}},
  author = {{A{\"i}t-Kaci}, Hassan},
  year = {1991},
  month = aug,
  publisher = {The MIT Press},
  doi = {10.7551/mitpress/7160.001.0001},
  urldate = {2025-02-20},
  abstract = {This tutorial demystifies one of the most important yet poorly understood aspects of logic programming, the Warren Abstract Machine or WAM. The author's step-by-step construction of the WAM adds features in a gradual manner, clarifying the complex aspects of the design and providing the first detailed study of WAM since it was designed in 1983. Developed by David H. D. Warren, the WAM is an abstract (nonphysical) computer that aids in the compilation and implementation of the Prolog programming language and offers techniques for compiling and optimizing symbolic computing that can be generalized beyond Prolog. Although the benefits of the WAM design have been widely accepted, few have been able to penetrate the WAM. This lucid introduction defines separate abstract machines for each conceptually separate part of the design and refines them, finally stitching them together to make a WAM. An index presents all of the critical concepts used in the WAM. It is assumed that readers have a clear understanding of the operational semantics of Prolog, in particular, of unification and backtracking, but a brief summary of the necessary Prolog notions is provided.             Contents Introduction {$\bullet$} Unification---Pure and Simple {$\bullet$} Flat Resolution {$\bullet$} Prolog {$\bullet$} Optimizing the Design {$\bullet$} Conclusion {$\bullet$} Appendixes},
  isbn = {978-0-262-25558-5},
  langid = {english},
  file = {/Users/william/Zotero/storage/V4VZYPVK/AÃ¯t-Kaci - 1991 - Warren's Abstract Machine A Tutorial Reconstruction.pdf}
}

@article{applebyGarbargecollectionProlog1988,
  title = {Garbarge Collection for {{Prolog}} Based on {{WAM}}},
  author = {Appleby, Karen and Carlsson, Mats and Haridi, Seif and Sahlin, Dan},
  year = {1988},
  month = jun,
  journal = {Commun. ACM},
  volume = {31},
  number = {6},
  pages = {719--741},
  issn = {0001-0782},
  doi = {10.1145/62959.62968},
  urldate = {2025-02-04},
  abstract = {The Warren abstract machine (WAM) has become a generally accepted standard Prolog implementation technique. Garbage collection is an important aspect in the implementation of any Prolog system. A synopsis of the WAM is presented and then marking and compaction algorithms are shown that take advantage of WAM's unique use of the data areas. Marking and compaction are performed on both the heap and the trail; both use pointer reversal techniques, which obviate the need for extra stack space. However, two bits for every pointer on the heap are reserved for the garbage collection algorithm. The algorithm can work on segments of the heap, which may lead to a significant reduction of the total garbage collection time. The time of the algorithms are linear in the size of the areas.},
  file = {/Users/william/Zotero/storage/AKVCYXFI/Appleby et al. - 1988 - Garbarge collection for Prolog based on WAM.pdf}
}

@inproceedings{bekkersDynamicMemoryManagement1992,
  title = {Dynamic Memory Management for Sequential Logic Programming Languages},
  booktitle = {Memory {{Management}}},
  author = {Bekkers, Y. and Ridoux, O. and Ungaro, L.},
  editor = {Bekkers, Yves and Cohen, Jacques},
  year = {1992},
  pages = {82--102},
  publisher = {Springer},
  address = {Berlin, Heidelberg},
  doi = {10.1007/BFb0017184},
  abstract = {Logic programming languages are becoming more complex with the introduction of new features such as constraints or terms with an equality theory. With this increase in complexity, they require more and more sophisticated memory management. This survey gives an insight into the memory management problems in sequential logic programming language implementations; it also describes the presently known solutions. It is meant to be understood by non-specialists in logic programming with good knowledge of memory management in general. We first describe a ``usefulness logic'' for run-time objects. Usefulness logic defines non-garbage objects. Next, memory management systems are presented from the most trivial original run-time system, with no real concern for memory problems, to elaborated run-time systems with memory management closely observing the usefulness logic. Finally, the choice of a garbage collection technique is discussed in relation with logic programming specificities.},
  isbn = {978-3-540-47315-2},
  langid = {english},
  keywords = {Garbage Collection,Garbage Collector,Logic Program,Logic Programming,Memory Management},
  file = {/Users/william/Zotero/storage/NC9EQD2G/Bekkers et al. - 1992 - Dynamic memory management for sequential logic programming languages.pdf}
}

@inproceedings{biermanUnderstandingTypeScript2014,
  title = {Understanding {{TypeScript}}},
  booktitle = {{{ECOOP}} 2014 -- {{Object-Oriented Programming}}},
  author = {Bierman, Gavin and Abadi, Mart{\'i}n and Torgersen, Mads},
  editor = {Jones, Richard},
  year = {2014},
  pages = {257--281},
  publisher = {Springer},
  address = {Berlin, Heidelberg},
  doi = {10.1007/978-3-662-44202-9_11},
  abstract = {TypeScript is an extension of JavaScript intended to enable easier development of large-scale JavaScript applications. While every JavaScript program is a TypeScript program, TypeScript offers a module system, classes, interfaces, and a rich gradual type system. The intention is that TypeScript provides a smooth transition for JavaScript programmers---well-established JavaScript programming idioms are supported without any major rewriting or annotations. One interesting consequence is that the TypeScript type system is not statically sound by design. The goal of this paper is to capture the essence of TypeScript by giving a precise definition of this type system on a core set of constructs of the language. Our main contribution, beyond the familiar advantages of a robust, mathematical formalization, is a refactoring into a safe inner fragment and an additional layer of unsafe rules.},
  isbn = {978-3-662-44202-9},
  langid = {english},
  keywords = {Call Signature,Object Type,Operational Semantic,Return Type,Type System},
  file = {/Users/william/Zotero/storage/5IZW6DIZ/Bierman et al. - 2014 - Understanding TypeScript.pdf}
}

@article{boehmspiralmodelsoftware1986,
  title = {A Spiral Model of Software Development and Enhancement},
  author = {Boehm, B},
  year = {1986},
  month = aug,
  journal = {SIGSOFT Softw. Eng. Notes},
  volume = {11},
  number = {4},
  pages = {14--24},
  issn = {0163-5948},
  doi = {10.1145/12944.12948},
  urldate = {2025-02-22},
  file = {/Users/william/Zotero/storage/YJP2TDKC/Boehm - 1986 - A spiral model of software development and enhancement.pdf}
}

@techreport{boylandStateMobileNetwork2019,
  title = {The {{State}} of {{Mobile Network Experience}}},
  author = {Boyland, Peter},
  year = {2019},
  month = may,
  institution = {Opensignal},
  file = {/Users/william/Zotero/storage/DZUH4PVT/the_state_of_mobile_experience_may_2019_0.pdf}
}

@misc{capellicCapelliCHhprolog2024,
  title = {{{CapelliC}}/Hhprolog},
  author = {CapelliC},
  year = {2024},
  month = aug,
  urldate = {2025-01-28},
  abstract = {hitchhiker Prolog - an implementation of a novel virtual machine},
  copyright = {MIT},
  keywords = {cpp,javascript,prolog,prolog-implementation,virtual-machine}
}

@inproceedings{carlssonFreezeindexingother1987,
  title = {Freeze, Indexing, and Other Implementation Issues in the {{WAM}}},
  booktitle = {4th {{International Conference}} on {{Logic Programming}} ({{ICLP}}'87), {{May}} 1987, {{Melbourne}}, {{Australia}}},
  author = {Carlsson, Mats},
  year = {1987},
  pages = {40--58},
  publisher = {The MIT Press},
  urldate = {2025-03-08},
  abstract = {DiVA portal is a finding tool for research publications and student theses written at the following 50 universities and research institutions.},
  langid = {english},
  file = {/Users/william/Zotero/storage/K9R66SGZ/record.html}
}

@article{carlssonimplementationdiffreeze1986,
  title = {An Implementation of Dif and Freeze in the {{WAM}}},
  author = {Carlsson, Mats},
  year = {1986},
  month = dec,
  abstract = {Two very useful extensions to Prolog's computation model, dif and freeze, were introduced with Prolog II. A method for their incorporation into the Warren Abstract Machine is presented. Under reasonable assumptions, the method does not incur any overhead on programs not using these extensions.},
  langid = {english},
  file = {/Users/william/Zotero/storage/3SLCCA6A/Carlsson - An implementation of dif and freeze in the WAM.pdf}
}

@article{cheneynonrecursivelistcompacting1970,
  title = {A Nonrecursive List Compacting Algorithm},
  author = {Cheney, C. J.},
  year = {1970},
  month = nov,
  journal = {Communications of the ACM},
  volume = {13},
  number = {11},
  pages = {677--678},
  issn = {0001-0782, 1557-7317},
  doi = {10.1145/362790.362798},
  urldate = {2025-03-06},
  abstract = {A simple nonrecursive list structure compacting scheme or garbage collector suitable for both compact and LISP-like list structures is presented. The algorithm avoids the need for recursion by using the partial structure as it is built up to keep track of those lists that have been copied.},
  langid = {english},
  file = {/Users/william/Zotero/storage/TUWNBGSN/Cheney - 1970 - A nonrecursive list compacting algorithm.pdf}
}

@inproceedings{chengGenerationalstackcollection1998,
  title = {Generational Stack Collection and Profile-Driven Pretenuring},
  booktitle = {Proceedings of the {{ACM SIGPLAN}} 1998 Conference on {{Programming}} Language Design and Implementation},
  author = {Cheng, Perry and Harper, Robert and Lee, Peter},
  year = {1998},
  month = may,
  pages = {162--173},
  publisher = {ACM},
  address = {Montreal Quebec Canada},
  doi = {10.1145/277650.277718},
  urldate = {2025-02-08},
  isbn = {978-0-89791-987-6},
  langid = {english},
  file = {/Users/william/Zotero/storage/LSWGXPJS/Cheng et al. - 1998 - Generational stack collection and profile-driven pretenuring.pdf}
}

@techreport{colmerauersystemecommunicationhommemachine,
  title = {{Un syst{\`e}me de communication homme-machine en Fran{\c c}ais}},
  author = {Colmerauer, Alain and Kanoui, Henry},
  langid = {french},
  file = {/Users/william/Zotero/storage/XZXNFRYN/Colmerauer and Kanoui - Un systÃ¨me de communication homme-machine en FranÃ§ais.pdf}
}

@misc{crichtonMultithreadingRustWasm2018,
  title = {Multithreading {{Rust}} and {{Wasm}}},
  author = {Crichton, Alex},
  year = {2018},
  month = oct,
  journal = {Rust and WebAssembly},
  urldate = {2025-01-29},
  abstract = {When WebAssembly was first shipped it was an MVP which, while minimal, has spawned a huge number of exciting projects which work today across all major browsers. Rust has capitalized on the wasm MVP's success as well with tools like wasm-bindgen and wasm-pack by making the MVP feel less minimal. WebAssembly is yet more ambitious, though! Since inception it's always been intended to extend the WebAssembly specification with new features and functionality.},
  howpublished = {https://rustwasm.github.io/2018/10/24/multithreading-rust-and-wasm.html},
  langid = {english},
  file = {/Users/william/Zotero/storage/RLXMTXXE/multithreading-rust-and-wasm.html}
}

@misc{crichtonwasmbindgenhttpsgithubcom2014,
  title = {Wasm-Bindgen. {{https://github.com/rustwasm/wasm-bindgen}}},
  author = {Crichton, Alex},
  year = {2014},
  urldate = {2025-01-28},
  file = {/Users/william/Zotero/storage/WZDPXEKR/wasm-bindgen.html}
}

@misc{cubiwanjsProlog2020,
  title = {{{jsProlog}}},
  author = {Cubiwan},
  year = {2020},
  month = apr,
  urldate = {2025-01-28},
  abstract = {Prolog interpreter in JS},
  keywords = {javascript,prolog}
}

@misc{davisonTreallaProloghttps2020,
  title = {Trealla {{Prolog}}. {{https://github.com/trealla-prolog/trealla}}},
  author = {Davison, Andrew George},
  year = {2020},
  urldate = {2025-02-01},
  abstract = {A compact, efficient Prolog interpreter written in plain-old C.},
  copyright = {MIT},
  keywords = {c,iso-prolog-standard,prolog,prolog-implementation,prolog-interpreter,prolog-programming-language}
}

@incollection{flachSimplyLogicalFirst2023,
  title = {Simply {{Logical}} -- {{The First Three Decades}}},
  booktitle = {Prolog: {{The Next}} 50 {{Years}}},
  author = {Flach, Peter and Sokol, Kacper and Wielemaker, Jan},
  editor = {Warren, David S. and Dahl, Veronica and Eiter, Thomas and Hermenegildo, Manuel V. and Kowalski, Robert and Rossi, Francesca},
  year = {2023},
  pages = {184--193},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-35254-6_15},
  urldate = {2025-02-05},
  abstract = {This paper charts the evolution of the Prolog textbook Simply Logical -- Intelligent Reasoning by Example from print with runnable programmes on a 3.5-inch diskette published in 1994, via various intermediate online versions, to the fully interactive online edition available today. Our aim is to investigate -- from both the writer's and the reader's perspectives -- the potential impact of technology on educational materials. The three authors of this paper present three distinct and complementary points of view, which come together to shape an interactive online book that offers an immersive learning experience. Peter describes the philosophy behind the original book and experiences teaching from it. Jan demonstrates how contemporary web programming has enabled a fully interactive realisation of the book's philosophy. Kacper reports how different technologies can be adopted to build a versatile authoring toolkit that underpins the interactive online edition of the book. Collating these distinct yet coherent perspectives allows us to reflect on future opportunities for interactive Prolog teaching materials arising from the continuous development of web technologies. The insights we offer should be of interest to teachers of Prolog as well as those wanting to find out about the latest educational technologies.},
  isbn = {978-3-031-35254-6},
  langid = {english},
  keywords = {Artificial Intelligence,Education,Interactive,Learning,Logic Programming,Prolog,SWI-Prolog,SWISH,Textbook},
  file = {/Users/william/Zotero/storage/CIX45PJH/Flach et al. - 2023 - Simply Logical â The First Three Decades.pdf}
}

@book{gammaDesignPatternsElements1995,
  title = {Design {{Patterns}}: {{Elements}} of {{Reusable Object-Oriented Software}}},
  shorttitle = {Design {{Patterns}}},
  author = {Gamma, Erich},
  year = {1995},
  series = {Addison-{{Wesley}} Professional Computing Series},
  publisher = {Addison-Wesley},
  isbn = {978-0-201-63361-0},
  lccn = {QA76.64 .D47 1995},
  keywords = {Computer software,Object-oriented programming (Computer science),Reusability,Software patterns}
}

@inproceedings{garcia-pradalessCASPInBrowserPlayground2022,
  title = {An s({{CASP}}) {{In-Browser Playground}} Based on {{Ciao Prolog}}},
  booktitle = {{{ICLP Workshops}}},
  author = {{Garc{\'i}a-Pradales}, Guillermo and Morales, Jos{\'e} F. and Hermenegildo, Manuel V. and Arias, Joaqu{\'i}n and Carro, Manuel},
  year = {2022},
  month = jan,
  urldate = {2025-01-29},
  langid = {english},
  file = {/Users/william/Zotero/storage/QNC8GZAX/GarcÃ­a-Pradales et al. - 2022 - An s(CASP) In-Browser Playground based on Ciao Prolog.pdf}
}

@inproceedings{haasBringingwebspeed2017,
  title = {Bringing the Web up to Speed with {{WebAssembly}}},
  booktitle = {Proceedings of the 38th {{ACM SIGPLAN Conference}} on {{Programming Language Design}} and {{Implementation}}},
  author = {Haas, Andreas and Rossberg, Andreas and Schuff, Derek L. and Titzer, Ben L. and Holman, Michael and Gohman, Dan and Wagner, Luke and Zakai, Alon and Bastien, J. F.},
  year = {2017},
  month = jun,
  series = {{{PLDI}} 2017},
  pages = {185--200},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  doi = {10.1145/3062341.3062363},
  urldate = {2025-02-01},
  abstract = {The maturation of the Web platform has given rise to sophisticated and demanding Web applications such as interactive 3D visualization, audio and video software, and games. With that, efficiency and security of code on the Web has become more important than ever. Yet JavaScript as the only built-in language of the Web is not well-equipped to meet these requirements, especially as a compilation target.  Engineers from the four major browser vendors have risen to the challenge and collaboratively designed a portable low-level bytecode called WebAssembly. It offers compact representation, efficient validation and compilation, and safe low to no-overhead execution. Rather than committing to a specific programming model, WebAssembly is an abstraction over modern hardware, making it language-, hardware-, and platform-independent, with use cases beyond just the Web. WebAssembly has been designed with a formal semantics from the start. We describe the motivation, design and formal semantics of WebAssembly and provide some preliminary experience with implementations.},
  isbn = {978-1-4503-4988-8},
  file = {/Users/william/Zotero/storage/8MAPBHE5/Haas et al. - 2017 - Bringing the web up to speed with WebAssembly.pdf}
}

@techreport{haygoodPrologBenchmarkSuite1989,
  title = {A {{Prolog Benchmark Suite}} for {{Aquarius}}},
  author = {Haygood, Ralph},
  year = {1989},
  month = mar,
  address = {USA},
  abstract = {This report describes a suite of benchmarks for Prolog implementation research. It includes an explanation of the format of the suite, which is meant to facilitate use of the benchmarks. The principal idea of this format is to maintain for each benchmark a master file from which particular instances - for particular Prolog execution systems, for particular statistics to capture, etc. - are generated automatically using a preprocessor. A preprocessor provided with the suite for this purpose is described, along with a related utility and a simple framework for execution time measurement. Source code for these is appended. Possibilities for future work with respect both to this suite and to Prolog benchmarking more generally are dis- cussed briefly. For each benchmark in the suite, source code and execution times under C Prolog and Quintus Prolog (compiled) on a Sun 3/60 are appended.},
  file = {/Users/william/Zotero/storage/63579BF6/Haygood - 1989 - A Prolog Benchmark Suite for Aquarius.pdf}
}

@techreport{hillLUSHresolutionitscompleteness1974,
  type = {{{DCL Memo}}},
  title = {{{LUSH-resolution}} and Its Completeness},
  author = {Hill, Robert},
  year = {1974},
  number = {78},
  institution = {University of Edinburgh},
  langid = {english},
  keywords = {Linear resolution with Unrestricted Selection function for Horn clauses,LUSH},
  annotation = {OCLC: 606046922}
}

@inproceedings{holzbaurMetastructuresvsattributed1992,
  title = {Metastructures vs. Attributed Variables in the Context of Extensible Unification},
  booktitle = {Programming {{Language Implementation}} and {{Logic Programming}}},
  author = {Holzbaur, Christian},
  editor = {Bruynooghe, Maurice and Wirsing, Martin},
  year = {1992},
  pages = {260--268},
  publisher = {Springer},
  address = {Berlin, Heidelberg},
  doi = {10.1007/3-540-55844-6_141},
  abstract = {We relate two mechanisms which aim at the extension of logic programming languages. The first mechanism directly extends syntactic unification through the introduction of a data type, whose (unification) semantics are specified through user-defined predicates. The second mechanism was utilized for the implementation of coroutining facilities, and was independently derived with optimal memory management for various Prolog extensions in mind. Experience from the application of both mechanisms to the realization of CLP languages, without leaving the logic programming context, enables us to reveal similarities and the potential with respect to this task. Constructive measures that narrow or close the gap between the two conceptual schemes are provided.},
  isbn = {978-3-540-47297-1},
  langid = {english},
  keywords = {Garbage Collector,Inference Step,Logic Programming,Logic Programming Language,Memory Management},
  file = {/Users/william/Zotero/storage/83D7PVWP/Holzbaur - 1992 - Metastructures vs. attributed variables in the context of extensible unification.pdf}
}

@misc{isoInformationtechnologyProgramming1995,
  title = {Information Technology --- {{Programming}} Languages --- {{Prolog}} (13211-1:1995)},
  author = {{ISO}},
  year = {1995},
  month = jun,
  number = {13211-1:1995}
}

@incollection{knuthArtComputerProgramming1997,
  title = {The {{Art}} of {{Computer Programming}}. {{Vol}}. 1 (3rd {{Edition}}): {{Fundamental Algorithms}}},
  shorttitle = {The Art of Computer Programming. {{Volume}} 1},
  author = {Knuth, Donald Ervin},
  year = {1997},
  publisher = {Addison-Wesley},
  isbn = {978-0-201-89683-1},
  langid = {english},
  file = {/Users/william/Zotero/storage/WIW7EG5X/The Art of Computer Programming, Vol. 1 Fundamental Algorithms, 3rd Edition (Donald E. Knuth) (z-lib.org).pdf}
}

@article{kornerFiftyYearsProlog2022,
  title = {Fifty {{Years}} of {{Prolog}} and {{Beyond}}},
  author = {K{\"o}rner, Philipp and Leuschel, Michael and Barbosa, Jo{\~a}o and Costa, V{\'i}tor Santos and Dahl, Ver{\'o}nica and Hermenegildo, Manuel V. and Morales, Jose F. and Wielemaker, Jan and Diaz, Daniel and Abreu, Salvador and Ciatto, Giovanni},
  year = {2022},
  month = nov,
  journal = {Theory and Practice of Logic Programming},
  volume = {22},
  number = {6},
  pages = {776--858},
  issn = {1471-0684, 1475-3081},
  doi = {10.1017/S1471068422000102},
  urldate = {2025-02-20},
  abstract = {Both logic programming in general and Prolog in particular have a long and fascinating history, intermingled with that of many disciplines they inherited from or catalyzed. A large body of research has been gathered over the last 50 years, supported by many Prolog implementations. Many implementations are still actively developed, while new ones keep appearing. Often, the features added by different systems were motivated by the interdisciplinary needs of programmers and implementors, yielding systems that, while sharing the ``classic'' core language, in particular, the main aspects of the ISO-Prolog standard, also depart from each other in other aspects. This obviously poses challenges for code portability. The field has also inspired many related, but quite different languages that have created their own communities. This article aims at integrating and applying the main lessons learned in the process of evolution of Prolog. It is structured into three major parts. First, we overview the evolution of Prolog systems and the community approximately up to the ISO standard, considering both the main historic developments and the motivations behind several Prolog implementations, as well as other logic programming languages influenced by Prolog. Then, we discuss the Prolog implementations that are most active after the appearance of the standard: their visions, goals, commonalities, and incompatibilities. Finally, we perform a SWOT analysis in order to better identify the potential of Prolog and propose future directions along with which Prolog might continue to add useful features, interfaces, libraries, and tools, while at the same time improving compatibility between implementations.},
  keywords = {evolution,logic programming systems,portability,Prolog,rationale,vision},
  file = {/Users/william/Zotero/storage/IS5ZTNXL/KÃ¶rner et al. - 2022 - Fifty Years of Prolog and Beyond.pdf}
}

@article{kosnerAlwaysEarlyMarc2012,
  title = {Always {{Early}}: {{Marc Andreessen}}'s {{Five Big Ideas That Have Shaped}} the {{Internet}}},
  shorttitle = {Always {{Early}}},
  author = {Kosner, Anthony Wing},
  year = {2012},
  month = apr,
  journal = {Forbes},
  urldate = {2025-02-01},
  abstract = {It is one thing to be right once, or even twice. But Marc Andreessen has been consistently right about where things are going for 20 years. What he is thinking about next? My guess  is that it has something to do with mobile.},
  chapter = {Tech},
  langid = {english},
  file = {/Users/william/Zotero/storage/ZR9QYW5I/always-early-marc-andreessens-five-big-ideas-that-have-shaped-the-internet.html}
}

@inproceedings{kowalskiPredicateLogicProgramming1974,
  title = {Predicate {{Logic}} as {{Programming Language}}},
  author = {Kowalski, Robert},
  year = {1974},
  month = jan,
  series = {{{IFIP Congr}}.},
  volume = {74},
  pages = {569--574},
  file = {/Users/william/Zotero/storage/C5H59Y2D/IFIP74.pdf}
}

@article{lagerPenginesWebLogic2014,
  title = {Pengines: {{Web Logic Programming Made Easy}}},
  shorttitle = {Pengines},
  author = {Lager, Torbj{\"o}rn and Wielemaker, Jan},
  year = {2014},
  month = jul,
  journal = {Theory and Practice of Logic Programming},
  volume = {14},
  number = {4-5},
  pages = {539--552},
  issn = {1471-0684, 1475-3081},
  doi = {10.1017/S1471068414000192},
  urldate = {2025-01-28},
  abstract = {When developing a (web) interface for a deductive database, functionality required by the client is provided by means of HTTP handlers that wrap the logical data access predicates. These handlers are responsible for converting between client and server data representations and typically include options for paginating results. Designing the web accessible API is difficult because it is hard to predict the exact requirements of clients. Pengines changes this picture. The client provides a Prolog program that selects the required data by accessing the logical API of the server. The pengine infrastructure provides general mechanisms for converting Prolog data and handling Prolog non-determinism. The Pengines library is small (2000 lines Prolog, 150 lines JavaScript). It greatly simplifies defining an AJAX based client for a Prolog program and provides non-deterministic RPC between Prolog processes as well as interaction with Prolog engines similar to Paul Tarau's engines. Pengines are available as a standard package for SWI-Prolog 7.1},
  langid = {english},
  keywords = {agent programming,distributed programming,query languages,web programming},
  file = {/Users/william/Zotero/storage/8YLVY8V7/Lager and Wielemaker - 2014 - Pengines Web Logic Programming Made Easy.pdf}
}

@article{lamComparativeAnalysisPartial1990,
  title = {A {{Comparative Analysis}} of {{Partial Deductors}} for {{Pure Prolog}}},
  author = {Lam, John K K and Kusalik, Anthony J},
  year = {1990},
  month = may,
  abstract = {Although use of partial deduction is prevalent in logic programming research, few implementation principles have been developed. Partial deductors are often cited in the literature with little explanation of their type, quality, or general applicativeness. Further, there is no taxonomy by which partial deduction systems can be characterized and compared. This paper describes progress towards solving this problem. Five partial deduction systems for (pure) Prolog are studied. Their general control structures are analyzed, with concentration on their solutions to the issues of when or what to unfold, when to terminate unfolding, and how to pass multiple solutions between subgoals. Seven sample programs are tested using the five partial deductors. Qualitative and quantitative measures of the residual programs are taken. The final results are a comparison of the partial deductors and their performance, and an initial taxonomy for partial deduction systems for (pure) Prolog.},
  langid = {english},
  file = {/Users/william/Zotero/storage/FASNWL7Y/Lam and Kusalik - A Comparative Analysis of Partial Deductors for Pure Prolog.pdf}
}

@inproceedings{liEfficientMemoryManagement2000,
  title = {Efficient Memory Management in a Merged Heap/Stack Prolog Machine},
  booktitle = {Proceedings of the 2nd {{ACM SIGPLAN}} International Conference on {{Principles}} and Practice of Declarative Programming},
  author = {Li, Xining},
  year = {2000},
  month = sep,
  pages = {245--256},
  publisher = {ACM},
  address = {Montreal Quebec Canada},
  doi = {10.1145/351268.351296},
  urldate = {2025-01-28},
  abstract = {Traditional Prolog implementations are based on the stack/heap memory architecture: the stack holds local variables and control information, whereas the heap stores data objects which outlive procedure activations. A stack frame can be deallocated when an activation ends while heap space can only be reclaimed on backtracking or by garbage collection. Conventional garbage collection methods may yield poor performance. In this paper, I present a novel memory management approach used in the implementation of Logic Virtual Machine (LVM). The LVM combines the stack and the heap into a single memory block for all dynamical memory requirements, supports coarse-grain two-stream uni cation, and embeds an e cient garbage collection algorithm, the Chronological Garbage Collection (CGC), to reclaim useless memory cells. An experimental LVM emulator has been implemented. Our experimental results show that the proposed approach has low runtime overhead, good virtual memory and cache performance, and very short, evenly distributed pause times during garbage collection. Some benchmarks even revealed that the CGC not only improves the program's cache performance by more than enough to pay its own cost, but also improves the program execution performance which is competitive with the SICStus fastcode.},
  isbn = {978-1-58113-265-6},
  langid = {english},
  file = {/Users/william/Zotero/storage/CIHCQ9RW/Li - 2000 - Efficient memory management in a merged heapstack prolog machine.pdf}
}

@article{linewtermrepresentation1998,
  title = {A New Term Representation Method for {{Prolog}}},
  author = {Li, Xining},
  year = {1998},
  month = jan,
  journal = {The Journal of Logic Programming},
  volume = {34},
  number = {1},
  pages = {43--57},
  issn = {0743-1066},
  doi = {10.1016/S0743-1066(97)00062-9},
  urldate = {2025-01-28},
  abstract = {Various Prolog systems can be classified into two categories: Structure Sharing (SS) and Structure Copying (SC). The fundamental distinction between SS and SC is the way in which they represent structures. SS represents a structure instance by a two-pointer molecule with one end toward the structure skeleton and the other toward a binding environment. On the other hand, SC makes a concrete copy of a structure whenever the structure is matched against a free variable. SS was used in earlier Prolog implementations, whereas SC has been accepted as the de facto standard in modern Prolog implementations. However, analysis and practical comparison of SS and SC claim that programs can be written that make any one method almost arbitrarily worse than the other. In this paper, I propose a new Prolog term representation approach: Program Sharing (PS). The major contribution of this work is that PS has the advantages of both SC (representing terms of different types to fit in the size of a machine word) and SS (low overhead in constructing a dynamic structure instance), and the concept of program sharing could be used to realize all-special-case instruction-driven unification. PS has been adopted in the design of a new Prolog abstract machine, the LAM12. I have implemented an experimental LAM12 emulator in C. Benchmarks show that this new approach is very promising in memory utilization and reasonably close to a very good SC-based system in performance.},
  file = {/Users/william/Zotero/storage/8F3MAIHH/Li - A NEW TERM REPRESENTATION METHOD FOR PROLOG.pdf;/Users/william/Zotero/storage/CAUI2AZ4/S0743106697000629.html}
}

@inproceedings{liuExploringMissedOptimizations2023,
  title = {Exploring {{Missed Optimizations}} in {{WebAssembly Optimizers}}},
  booktitle = {Proceedings of the 32nd {{ACM SIGSOFT International Symposium}} on {{Software Testing}} and {{Analysis}}},
  author = {Liu, Zhibo and Xiao, Dongwei and Li, Zongjie and Wang, Shuai and Meng, Wei},
  year = {2023},
  month = jul,
  pages = {436--448},
  publisher = {ACM},
  address = {Seattle WA USA},
  doi = {10.1145/3597926.3598068},
  urldate = {2025-01-28},
  abstract = {The prosperous trend of deploying complex applications to web browsers has boosted the development of WebAssembly (wasm) compilation toolchains. Software written in different high-level programming languages are compiled into wasm executables, which can be executed fast and safely in a virtual machine. The performance of wasm executables depends highly on compiler optimizations. Despite the prosperous use of wasm executables, recent research has indicated that real-world wasm applications are slower than anticipated, suggesting deficiencies in wasm optimizations. This paper aims to present the first systematic and in-depth understanding of the status quo of wasm optimizations. To do so, we present Ditwo, a differential testing framework to uncover missed optimizations (MO) of wasm optimizers. Ditwo compiles a C program into both native x86 executable and wasm executable, and differentiates optimization indication traces (OITraces) logged by running each executable to uncover MO. Each OITrace is composed with global variable writes and function calls, two performance indicators that practically and systematically reflect the optimization degree across wasm and native executables. Our analysis of the official wasm optimizer, wasm-opt, successfully identifies 1,293 inputs triggering MO of wasm-opt. With extensive manual effort, we identify nine root causes for all MO, and we estimate that fixing discovered MO can result in a performance improvement of at least 17.15\%. We also summarize four lessons from our findings to deliver better wasm optimizations.},
  isbn = {979-8-4007-0221-1},
  langid = {english},
  file = {/Users/william/Zotero/storage/JTKKLDTC/Liu et al. - 2023 - Exploring Missed Optimizations in WebAssembly Optimizers.pdf}
}

@book{lloydFoundationsLogicProgramming1984,
  title = {Foundations of {{Logic Programming}}},
  author = {Lloyd, John Wylie},
  year = {1984},
  publisher = {Springer},
  address = {Berlin, Heidelberg},
  doi = {10.1007/978-3-642-96826-6},
  urldate = {2025-02-13},
  copyright = {http://www.springer.com/tdm},
  isbn = {978-3-642-96828-0 978-3-642-96826-6},
  langid = {english},
  keywords = {algorithms,artificial intelligence,intelligence,logic,logic programming,Mathematica,programming,programming language,Resolution,semantics},
  file = {/Users/william/Zotero/storage/EQ58DVTY/Lloyd - 1984 - Foundations of Logic Programming.pdf}
}

@article{martelliEfficientUnificationAlgorithm1982,
  title = {An {{Efficient Unification Algorithm}}},
  author = {Martelli, Alberto and Montanari, Ugo},
  year = {1982},
  month = apr,
  journal = {ACM Transactions on Programming Languages and Systems},
  volume = {4},
  number = {2},
  pages = {258--282},
  issn = {0164-0925, 1558-4593},
  doi = {10.1145/357162.357169},
  urldate = {2025-01-28},
  langid = {english},
  file = {/Users/william/Zotero/storage/G9NJ2249/Martelli and Montanari - 1982 - An Efficient Unification Algorithm.pdf}
}

@article{moralesLightweightcompilationCLP2012,
  title = {Lightweight Compilation of ({{C}}){{LP}} to {{JavaScript}}},
  author = {Morales, Jose F. and Haemmerl{\'e}, R{\'e}my and Carro, Manuel and Hermenegildo, Manuel V.},
  year = {2012},
  month = jul,
  journal = {Theory and Practice of Logic Programming},
  volume = {12},
  number = {4-5},
  pages = {755--773},
  issn = {1475-3081, 1471-0684},
  doi = {10.1017/S1471068412000336},
  urldate = {2025-01-30},
  abstract = {We present and evaluate a compiler from Prolog (and extensions) to JavaScript which makes it possible to use (constraint) logic programming to develop the client side of web applications while being compliant with current industry standards. Targeting JavaScript makes (C)LP programs executable in virtually every modern computing device with no additional software requirements from the point of view of the user. In turn, the use of a very high-level language facilitates the development of high-quality, complex software. The compiler is a back end of the Ciao system and supports most of its features, including its module system and its rich language extension mechanism based on packages. We present an overview of the compilation process and a detailed description of the run-time system, including the support for modular compilation into separate JavaScript code. We demonstrate the maturity of the compiler by testing it with complex code such as a CLP(FD) library written in Prolog with attributed variables. Finally, we validate our proposal by measuring the performance of some LP and CLP(FD) benchmarks running on top of major JavaScript engines.},
  keywords = {Ciao,implementation of Prolog,JavaScript,logic programming system,modules,Prolog,web},
  file = {/Users/william/Zotero/storage/FY8EXMH2/Morales et al. - 2012 - Lightweight compilation of (C)LP to JavaScript.pdf}
}

@article{morrisTimeSpaceefficientGarbage1978,
  title = {A Time- and Space-Efficient Garbage Compaction Algorithm},
  author = {Morris, F. Lockwood},
  year = {1978},
  month = aug,
  journal = {Communications of the ACM},
  volume = {21},
  number = {8},
  pages = {662--665},
  issn = {0001-0782, 1557-7317},
  doi = {10.1145/359576.359583},
  urldate = {2025-01-28},
  abstract = {Given an area of storage containing scattered, marked nodes of differing sizes, one may wish to rearrange them into a compact mass at one end of the area while revising all pointers to marked nodes to show their new locations. An algorithm is described here which accomplishes this task in linear time relative to the size of the storage area, and in a space of the order of one bit for each pointer. The algorithm operates by reversibly encoding the situation (that a collection of locations point to a single location) by a linear list, emanating from the pointed-to location, passing through the pointing locations, and terminating with the pointed-to location's transplanted contents.},
  langid = {english},
  file = {/Users/william/Zotero/storage/32HHAFNS/Morris - 1978 - A time- and space-efficient garbage compaction algorithm.pdf}
}

@article{mycroftpolymorphictypesystem1984,
  title = {A Polymorphic Type System for Prolog},
  author = {Mycroft, Alan and O'Keefe, Richard A.},
  year = {1984},
  month = aug,
  journal = {Artificial Intelligence},
  volume = {23},
  number = {3},
  pages = {295--307},
  issn = {00043702},
  doi = {10.1016/0004-3702(84)90017-1},
  urldate = {2025-04-05},
  abstract = {We describe a polymorphic type scheme for Prolog which makes static type checking possible. Polymorphism gives a good degree of flexibility to the type system, and makes it intrude very little on a user's programming style. The only additions to the language are type declarations, which an interpreter can ignore if it so desires, with the guarantee that a well-typed program will behave identically with or without type checking. Our implementation is discussed and we observe that the type resolution problem for a Prolog program is another Prolog (meta )program.},
  copyright = {https://www.elsevier.com/tdm/userlicense/1.0/},
  langid = {english},
  file = {/Users/william/Zotero/storage/XJ2JD5J7/Mycroft and O'Keefe - 1984 - A polymorphic type system for prolog.pdf}
}

@inproceedings{ocarizajr.JavaScriptErrorsWild2011,
  title = {{{JavaScript Errors}} in the {{Wild}}: {{An Empirical Study}}},
  shorttitle = {{{JavaScript Errors}} in the {{Wild}}},
  booktitle = {2011 {{IEEE}} 22nd {{International Symposium}} on {{Software Reliability Engineering}}},
  author = {Ocariza Jr., Frolin S. and Pattabiraman, Karthik and Zorn, Benjamin},
  year = {2011},
  month = nov,
  pages = {100--109},
  publisher = {IEEE},
  address = {Hiroshima, Japan},
  doi = {10.1109/ISSRE.2011.28},
  urldate = {2025-02-11},
  abstract = {Client-side JavaScript is being widely used in popular web applications to improve functionality, increase responsiveness, and decrease load times. However, it is challenging to build reliable applications using JavaScript. This paper presents an empirical characterization of the error messages printed by JavaScript code in web applications, and attempts to understand their root causes. We find that JavaScript errors occur in production web applications, and that the errors fall into a small number of categories. We further find that both non-deterministic and deterministic errors occur in the applications, and that the speed of testing plays an important role in exposing errors. Finally, we study the correlations among the static and dynamic properties of the application and the frequency of errors in it in order to understand the root causes of the errors.},
  isbn = {978-1-4577-2060-4 978-0-7695-4568-4},
  langid = {english},
  file = {/Users/william/Zotero/storage/4R49XD6W/Ocariza Jr. et al. - 2011 - JavaScript Errors in the Wild An Empirical Study.pdf}
}

@inproceedings{pittomvilsrealtimegarbagecollector1985,
  title = {Towards a Real-Time Garbage Collector for {{Prolog}}},
  booktitle = {International {{Symposium}} on {{Logic Programming}}},
  author = {Pittomvils, Edwin and Bruynooghe, Maurice and Willems, Yves D.},
  year = {1985},
  month = jul,
  file = {/Users/william/Zotero/storage/64GZ7SKX/LPS85.pdf}
}

@article{riazaTauPrologProlog2024,
  title = {Tau {{Prolog}}: {{A Prolog Interpreter}} for the {{Web}}},
  shorttitle = {Tau {{Prolog}}},
  author = {Riaza, Jos{\'e} A.},
  year = {2024},
  month = jan,
  journal = {Theory and Practice of Logic Programming},
  volume = {24},
  number = {1},
  pages = {1--21},
  issn = {1471-0684, 1475-3081},
  doi = {10.1017/S1471068423000352},
  urldate = {2025-01-28},
  abstract = {Tau Prolog is a client-side Prolog interpreter fully implemented in JavaScript, which aims at implementing the ISO Prolog Standard. Tau Prolog has been developed to be used with either Node.js or a browser seamlessly, and therefore, it has been developed following a non-blocking, callback-based approach to avoid blocking web browsers. Taking the best from JavaScript and Prolog, Tau Prolog allows the programmer to handle browser events and manipulate the Document Object Model (DOM) of a web using Prolog predicates. In this paper we describe the architecture of Tau Prolog and its main packages for interacting with the Web, and we present its programming environment.},
  langid = {english},
  keywords = {JavaScript,logic programming,Prolog interpreter,Tau Prolog},
  file = {/Users/william/Zotero/storage/3ZIC5VC7/Riaza - 2024 - Tau Prolog A Prolog Interpreter for the Web.pdf}
}

@techreport{rossbergWebAssemblyCoreSpecification2022,
  title = {{{WebAssembly Core Specification}}},
  author = {Rossberg, Andreas},
  year = {2022},
  month = apr,
  institution = {W3C},
  langid = {english},
  file = {/Users/william/Zotero/storage/KG64TKK3/Group and Rossberg - WebAssembly Specification.pdf}
}

@techreport{sahlinVariableShuntingWAM1991,
  type = {Technical {{Report}}},
  title = {Variable {{Shunting}} for the {{WAM}}},
  author = {Sahlin, Dan and Carlsson, Mats},
  year = {1991},
  month = mar,
  institution = {{European Research Consortium for Informatics and Mathematics at SICS}},
  abstract = {This paper describes how to extend the garbage collection for WAM so that it will shunt chains of bound variables if possible. Doing so has two advantages: 1. Space is saved by making it possible to deallocate the intermediate cells. This is particularly useful when those cells are associated with frozen goals. 2. Later dereferencing is speeded up by not having to follow long variable chains. The main complication of this optimization is the treatment of the trailed variables. We claim that all possible chains of variables are shunted by this algorithm. The algorithm has been implemented in SICStus Prolog, and benchmark results are presented in this paper. The full source code for the shunting algorithm is given in this paper.},
  file = {/Users/william/Zotero/storage/58LUWIT3/Sahlin and Carlsson - Variable Shunting for the WAM.pdf}
}

@inproceedings{sanchez-rolaClockClockTimeBased2018,
  title = {Clock {{Around}} the {{Clock}}: {{Time-Based Device Fingerprinting}}},
  shorttitle = {Clock {{Around}} the {{Clock}}},
  author = {{Sanchez-Rola}, Iskander and Santos, Igor and Balzarotti, Davide},
  year = {2018},
  month = oct,
  series = {{{CCS}} '18},
  pages = {1502--1514},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  doi = {10.1145/3243734.3243796},
  urldate = {2025-01-31},
  abstract = {Physical device fingerprinting exploits hardware features to uniquely identify a machine. This technique has been used for authentication, license binding, or attackers identification, among other tasks. More recently, hardware features have also been introduced to identify web users and perform web tracking. A particular type of hardware fingerprint exploits differences in the computer internal clock signals. However, previous methods to test for these differences relied on complex experiments performed by running native code in the target machine. In this paper, we show a new way to compute a hardware finger- printing, based on timing the execution of sequences of instructions readily available in API functions. Due to its simplicity, this method can also be performed remotely by simply timing few seemingly innocuous lines of JavaScript code. We tested our approach with different functions, such as common string manipulation or widespread cryptographic routines, and found that several of them can be used as basic blocks for fingerprinting. Using this technique, we implemented a tool called CryptoFP. We tested its native implementation in a homogeneous scenario, to distinguish among a perfectly identical (both in software and hardware) set of computers. CryptoFP was able to correctly discriminate all the identical computers in this scenario and recognize the same computer also under different CPU load configurations, outperforming every other hardware fingerprinting method. We then show how CryptoFP can be implemented using a combination of the HTML5 Cryptography API and standard timing API for web device fingerprinting. In this case, we compared our method, both in the same homogeneous scenario and by performing an experiment with real-world users running heterogeneous devices, against other state-of-the-art web device fingerprinting solutions. In both cases, our approach clearly outperforms all existing methods.},
  isbn = {978-1-4503-5693-0},
  file = {/Users/william/Zotero/storage/H86YDFD3/Sanchez-Rola et al. - 2018 - Clock Around the Clock Time-Based Device Fingerprinting.pdf}
}

@inproceedings{santoscostaDemandDrivenIndexingProlog2007,
  title = {Demand-{{Driven Indexing}} of {{Prolog Clauses}}},
  booktitle = {Logic {{Programming}}},
  author = {Santos Costa, V{\'i}tor and Sagonas, Konstantinos and Lopes, Ricardo},
  editor = {Dahl, V{\'e}ronica and Niemel{\"a}, Ilkka},
  year = {2007},
  pages = {395--409},
  publisher = {Springer},
  address = {Berlin, Heidelberg},
  doi = {10.1007/978-3-540-74610-2_27},
  abstract = {As logic programming applications grow in size, Prolog systems need to efficiently access larger and larger data sets and the need for any- and multi-argument indexing becomes more and more profound. Static generation of multi-argument indexing is one alternative, but applications often rely on features that are inherently dynamic which makes static techniques inapplicable or inaccurate. Another alternative is to employ dynamic schemes for flexible demand-driven indexing of Prolog clauses. We propose such schemes and discuss issues that need to be addressed for their efficient implementation in the context of WAM-based Prolog systems. We have implemented demand-driven indexing in two different Prolog systems and have been able to obtain non-negligible performance speedups: from a few percent up to orders of magnitude. Given these results, we see very little reason for Prolog systems not to incorporate some form of dynamic indexing based on actual demand. In fact, we see demand-driven indexing as only the first step towards effective runtime optimization of Prolog programs.},
  isbn = {978-3-540-74610-2},
  langid = {english},
  keywords = {Hash Table,Index Table,Inductive Logic Programming,Logic Programming,Memory Usage},
  file = {/Users/william/Zotero/storage/XGYKJGQD/Santos Costa et al. - 2007 - Demand-Driven Indexing of Prolog Clauses.pdf}
}

@misc{softwarefreedomconservancySeleniumhttpsgithubcom2025,
  title = {Selenium. {{https://github.com/SeleniumHQ/selenium}}},
  author = {{Software Freedom Conservancy}},
  year = {2025}
}

@article{steeleMultiprocessingCompactifyingGarbage1975,
  title = {Multiprocessing {{Compactifying Garbage Collection}}},
  author = {Steele, Guy L.},
  year = {1975},
  month = sep,
  journal = {Communications of the ACM},
  volume = {18},
  number = {9},
  pages = {495--508},
  issn = {0001-0782, 1557-7317},
  doi = {10.1145/361002.361005},
  urldate = {2025-03-06},
  abstract = {Algorithms for a multiprocessing compactifying garbage collector are presented and discussed. The simple case of two processors, one performing LISP-like list operations and the other performing garbage collection continuously, is thoroughly examined. The necessary capabilities of each processor are defined, as well as interprocessor communication and interlocks. Complete procedures for garbage collection and for standard list processing primitives are presented and thoroughly explained. Particular attention is given to the problems of marking and relocating list cells while another processor may be operating on them. The primary aim throughout is to allow the list processor to run unimpeded while the other processor reclaims list storage The more complex case involving several list processors and one or more garbage collection processors are also briefly discussed.},
  langid = {english},
  file = {/Users/william/Zotero/storage/6YE5ZIS6/Steele - 1975 - Multiprocessing compactifying garbage collection.pdf}
}

@misc{SWIProlog2,
  title = {{{SWI-Prolog}} -- (-{$>$})/2},
  urldate = {2025-03-08},
  howpublished = {https://www.swi-prolog.org/pldoc/man?predicate=-\%3E/2},
  file = {/Users/william/Zotero/storage/AXUXQTRF/man.html}
}

@article{tarauHitchhikersGuideReinventing2018,
  title = {A {{Hitchhiker}}'s {{Guide}} to {{Reinventing}} a {{Prolog Machine}}},
  author = {Tarau, Paul},
  year = {2018},
  journal = {OASIcs, Volume 58, ICLP 2017},
  volume = {58},
  pages = {10:1-10:16},
  publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik},
  issn = {2190-6807},
  doi = {10.4230/OASICS.ICLP.2017.10},
  urldate = {2025-01-28},
  abstract = {We take a fresh, ``clean-room'' look at implementing Prolog by deriving its translation to an executable representation and its execution algorithm from a simple Horn Clause meta-interpreter. The resulting design has some interesting properties. The heap representation of terms and the abstract machine instruction encodings are the same. No dedicated code area is used as the code is placed directly on the heap. Unification and indexing operations are orthogonal. Filtering of matching clauses happens without building new structures on the heap. Variables in function and predicate symbol positions are handled with no performance penalty. A simple Englishlike syntax is used as an intermediate representation for clauses and goals and the same simple syntax can be used by programmers directly as an alternative to classic Prolog syntax. Solutions of (multiple) logic engines are exposed as answer streams that can be combined through typical functional programming patterns, with flexibility to stop, resume, encapsulate and interleave executions. Performance of a basic interpreter implementing our design is within a factor of 2 of a highly optimized compiled WAM-based system using the same host language.},
  collaborator = {Rocha, Ricardo and Son, Tran Cao and Mears, Christopher and Saeedloei, Neda},
  copyright = {Creative Commons Attribution 3.0 Unported license, info:eu-repo/semantics/openAccess},
  isbn = {9783959770583},
  langid = {english},
  keywords = {answer streams,heap representation of terms and code,immutable goal stacks,multi-arg,natural language syntax for clauses,Prolog abstract machines},
  file = {/Users/william/Zotero/storage/JCBR73RX/Tarau - 2018 - A Hitchhiker's Guide to Reinventing a Prolog Machine.pdf}
}

@misc{thelalrpopprojectdevelopersLALRPOPhttpsgithubcom2015,
  title = {{{LALRPOP}}. {{https://github.com/lalrpop/lalrpop}}},
  author = {{The LALRPOP Project Developers}},
  year = {2015},
  urldate = {2025-01-28},
  file = {/Users/william/Zotero/storage/SAKV92BT/lalrpop.html}
}

@misc{UsingSWIPrologYour,
  title = {Using {{SWI-Prolog}} in Your Browser ({{WASM}})},
  urldate = {2025-01-28},
  howpublished = {https://www.swi-prolog.org/pldoc/man?section=wasm},
  file = {/Users/william/Zotero/storage/U2GUGHJA/man.html}
}

@techreport{warrenAbstractPrologInstruction1983,
  title = {An {{Abstract Prolog Instruction Set}}},
  author = {Warren, David H. D.},
  year = {1983},
  urldate = {2025-01-28},
  file = {/Users/william/Zotero/storage/LBDZ4MNK/1571698599543155072.html}
}

@techreport{warrenImplementingPrologCompiling1977,
  title = {Implementing {{Prolog}}: {{Compiling Predicate Logic Programs}}},
  author = {Warren, David H. D.},
  year = {1977},
  month = may,
  institution = {University of Edinburgh},
  file = {/Users/william/Zotero/storage/5N8HLIVP/Warren-Implementing_Prolog_Volume_1-1977_05.pdf}
}

@inproceedings{wielemakerPreciseGarbageCollection2008,
  title = {Precise {{Garbage Collection}} in {{Prolog}}},
  author = {Wielemaker, J. and Neumerkel, U.},
  year = {2008},
  urldate = {2025-01-28},
  abstract = {In this paper we present a series of tiny programs that verify that a Prolog heap garbage collector can find specific forms of garbage. Only 2 out of our tested 7 Prolog systems pass all tests. Comparing memory usage on realistic programs dealing with finite datastructures using both poor and precise garbage collection shows only a small difference, providing a plausible explanation why many Prolog implementors did not pay much attention to this issue. Attributed variables allow for creating infinite lazy datastructures. We prove that such datastructures have great practical value and their introduction requires `precise' garbage collection. The Prolog community knows about three techniques to reach at precise garbage collection. We summarise these techniques and provide more details on scanning virtual machine instructions to infer reachability in a case study.},
  file = {/Users/william/Zotero/storage/FPB9P3JJ/Wielemaker and Neumerkel - 2008 - Precise Garbage Collection in Prolog.pdf}
}

@article{wielemakerSWIProlog2012,
  title = {{{SWI-Prolog}}},
  author = {Wielemaker, Jan and Schrijvers, Tom and Triska, Markus and Lager, Torbj{\"o}rn},
  year = {2012},
  month = jan,
  journal = {Theory and Practice of Logic Programming},
  volume = {12},
  number = {1-2},
  pages = {67--96},
  issn = {1475-3081, 1471-0684},
  doi = {10.1017/S1471068411000494},
  urldate = {2025-01-28},
  abstract = {SWI-Prolog is neither a commercial Prolog system nor a purely academic enterprise, but increasingly a community project. The core system has been shaped to its current form while being used as a tool for building research prototypes, primarily for knowledge-intensive and interactive systems. Community contributions have added several interfaces and the constraint (CLP) libraries. Commercial involvement has created the initial garbage collector, added several interfaces and two development tools: PlDoc (a literate programming documentation system) and PlUnit (a unit testing environment).In this article, we present SWI-Prolog as an integrating tool, supporting a wide range of ideas developed in the Prolog community and acting as glue between foreign resources. This article itself is the glue between technical articles on SWI-Prolog, providing context and experience in applying them over a longer period.},
  langid = {english},
  keywords = {logic programming system,Prolog},
  file = {/Users/william/Zotero/storage/TWL4WGX5/Wielemaker et al. - 2012 - SWI-Prolog.pdf}
}

@misc{wielemakerSWIPrologbenchmarksuite2010,
  title = {{{SWI-Prolog}} Benchmark Suite},
  author = {Wielemaker, Jan},
  year = {2010},
  urldate = {2025-01-30},
  abstract = {Prolog benchmarks (`van Roy' set)},
  howpublished = {SWI-Prolog}
}

@misc{wielemakerSWISHSWIPrologSharing2015,
  title = {{{SWISH}}: {{SWI-Prolog}} for {{Sharing}}},
  shorttitle = {{{SWISH}}},
  author = {Wielemaker, Jan and Lager, Torbj{\"o}rn and Riguzzi, Fabrizio},
  year = {2015},
  month = nov,
  number = {arXiv:1511.00915},
  eprint = {1511.00915},
  primaryclass = {cs},
  publisher = {arXiv},
  doi = {10.48550/arXiv.1511.00915},
  urldate = {2025-01-28},
  abstract = {Recently, we see a new type of interfaces for programmers based on web technology. For example, JSFiddle, IPython Notebook and R-studio. Web technology enables cloud-based solutions, embedding in tutorial web pages, atractive rendering of results, web-scale cooperative development, etc. This article describes SWISH, a web front-end for Prolog. A public website exposes SWI-Prolog using SWISH, which is used to run small Prolog programs for demonstration, experimentation and education. We connected SWISH to the ClioPatria semantic web toolkit, where it allows for collaborative development of programs and queries related to a dataset as well as performing maintenance tasks on the running server and we embedded SWISH in the Learn Prolog Now! online Prolog book.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Artificial Intelligence,Computer Science - Programming Languages},
  file = {/Users/william/Zotero/storage/NUTS34M4/Wielemaker et al. - 2015 - SWISH SWI-Prolog for Sharing.pdf;/Users/william/Zotero/storage/Y9XWCBAL/1511.html}
}

@inproceedings{wielemakerUsingPrologFundament2007,
  title = {Using {{Prolog}} as the {{Fundament}} for {{Applications}} on the {{Semantic Web}}},
  booktitle = {Applications of {{Logic Programming}} to the {{Web}}, {{Semantic Web}} and {{Semantic Web Services}}},
  author = {Wielemaker, J. and Hildebrand, M. and Ossenbruggen, J. V.},
  year = {2007},
  series = {{{ICLP}} 2007},
  pages = {91--106},
  address = {Porto, Portugal},
  urldate = {2025-02-02},
  abstract = {This article describes the experiences developing a Semantic Web application entirely in Prolog. The application, a demonstrator that provides access to multiple art collections and linking these using cultural heritage vocabularies, has won the first price in the ISWC-06 contest on SemanticWeb end-user applications. In this document we concentrate on the Prolog-based architecture, describing experiences and vital aspects of the design.},
  file = {/Users/william/Zotero/storage/LLSIAEAZ/Wielemaker et al. - 2007 - Prolog as the Fundament for Applications on the Semantic Web.pdf}
}

@article{wirfs-brockJavaScriptfirst202020a,
  title = {{{JavaScript}}: The First 20 Years},
  shorttitle = {{{JavaScript}}},
  author = {{Wirfs-Brock}, Allen and Eich, Brendan},
  year = {2020},
  month = jun,
  journal = {Proceedings of the ACM on Programming Languages},
  volume = {4},
  number = {HOPL},
  pages = {1--189},
  issn = {2475-1421},
  doi = {10.1145/3386327},
  urldate = {2025-02-11},
  abstract = {How a sidekick scripting language for Java, created at Netscape in a ten-day hack, ships first as a de facto Web standard and eventually becomes the world's most widely used programming language. This paper tells the story of the creation, design, evolution, and standardization of the JavaScript language over the period of 1995--2015. But the story is not only about the technical details of the language. It is also the story of how people and organizations competed and collaborated to shape the JavaScript language which dominates the Web of 2020.},
  langid = {english},
  file = {/Users/william/Zotero/storage/SJA327AH/Wirfs-Brock and Eich - 2020 - JavaScript the first 20 years.pdf}
}

@inproceedings{yanUnderstandingPerformanceWebAssembly2021a,
  title = {Understanding the Performance of {{WebAssembly}} Applications},
  booktitle = {Proceedings of the 21st {{ACM Internet Measurement Conference}}},
  author = {Yan, Yutian and Tu, Tengfei and Zhao, Lijian and Zhou, Yuchen and Wang, Weihang},
  year = {2021},
  month = nov,
  pages = {533--549},
  publisher = {ACM},
  address = {Virtual Event},
  doi = {10.1145/3487552.3487827},
  urldate = {2025-01-28},
  abstract = {WebAssembly is the newest language to arrive on the web. It features a compact binary format, making it fast to be loaded and decoded. While WebAssembly is generally expected to be faster than JavaScript, there have been mixed results in proving which code is faster. Little research has been done to comprehend WebAssembly's performance benefit. In this paper, we conduct a systematic study to understand the performance of WebAssembly applications and compare it with JavaScript. Our measurements were performed on three sets of subject programs with diverse settings. Among others, our findings include: (1) WebAssembly compilers are commonly built atop LLVM, where their optimizations are not tailored for WebAssembly. We show that these optimizations often become ineffective for WebAssembly, leading to counter-intuitive results. (2) JIT optimization has a significant impact on JavaScript performance. However, no substantial performance increase was observed for WebAssembly with JIT. (3) The performance of WebAssembly and JavaScript varies substantially depending on the execution environment. (4) WebAssembly uses significantly more memory than its JavaScript counterparts. We hope that our findings can help WebAssembly tooling developers identify optimization opportunities. We also report the challenges encountered when compiling C benchmarks to WebAssembly and discuss our solutions.},
  isbn = {978-1-4503-9129-0},
  langid = {english},
  file = {/Users/william/Zotero/storage/XSKAPXCS/Yan et al. - 2021 - Understanding the performance of webassembly applications.pdf}
}

@misc{zakaiBinaryenhttpsgithubcom2015,
  title = {Binaryen. {{https://github.com/WebAssembly/binaryen}}},
  author = {Zakai, Alon},
  year = {2015},
  urldate = {2025-03-28},
  abstract = {Optimizer and compiler/toolchain library for WebAssembly},
  copyright = {Apache-2.0},
  keywords = {c-plus-plus,compilers,emscripten,hacktoberfest,webassembly}
}

@inproceedings{zakaiEmscriptenLLVMtoJavaScriptcompiler2011,
  title = {Emscripten: An {{LLVM-to-JavaScript}} Compiler},
  shorttitle = {Emscripten},
  booktitle = {Proceedings of the {{ACM}} International Conference Companion on {{Object}} Oriented Programming Systems Languages and Applications Companion},
  author = {Zakai, Alon},
  year = {2011},
  month = oct,
  series = {{{OOPSLA}} '11},
  pages = {301--312},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  doi = {10.1145/2048147.2048224},
  urldate = {2025-02-10},
  abstract = {We present Emscripten, a compiler from LLVM (Low Level Virtual Machine) assembly to JavaScript. This opens up two avenues for running code written in languages other than JavaScript on the web: (1) Compile code directly into LLVM assembly, and then compile that into JavaScript using Emscripten, or (2) Compile a language's entire runtime into LLVM and then JavaScript, as in the previous approach, and then use the compiled runtime to run code written in that language. For example, the former approach can work for C and C++, while the latter can work for Python; all three examples open up new opportunities for running code on the web.Emscripten itself is written in JavaScript and is available under the MIT license (a permissive open source license), at http://www.emscripten.org. As a compiler from LLVM to JavaScript, the challenges in designing Emscripten are somewhat the reverse of the norm - one must go from a low-level assembly into a high-level language, and recreate parts of the original high-level structure of the code that were lost in the compilation to low-level LLVM. We detail the methods used in Emscripten to deal with those challenges, and in particular present and prove the validity of Emscripten's Relooper algorithm, which recreates high-level loop structures from low-level branching data.},
  isbn = {978-1-4503-0942-4},
  file = {/Users/william/Zotero/storage/4KV3CQZY/Zakai - 2011 - Emscripten an LLVM-to-JavaScript compiler.pdf}
}
